---
title: 第 16 章 模板与泛型编程
categories:
- Book
- C++ Primer （第 5 版）
---
# 16.1 定义模板

- 一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或引用（必须具有静态的生存期）。
- 为了实例化模板，编译器需要掌握函数模板或类模板成员函数的定义，而非仅仅声明。
- 编译器处理模板流程：
  - 编译模板本身，仅处理语法错误，例如忘记分号。
  - 遇到模板使用时，检查调用是否正确，例如参数数目和类型。
  - 模板实例化，只有这个阶段可以发现类型相关的错误。
- 在模板内部定义 `typedef` 时，如果被定义的对象是从模板参数中获取的，那么需要显式声明为 `typename` 以告知编译器此处代指的是一个类型而非成员变量（因为此时编译器不知道 `T` 的成员，需要等到模板实例化时才能知道）。
  
  ```cpp
  template <typename T>
  class B {
    public:
    typedef typename T::some_type internal_type;
    typename T::some_type t_var; // 包括声明变量也需要手动指明此处 T::some_type 指的是类型而非成员变量
  };
  ```
- 在模板类外定义成员函数需要指定模板参数：
  
  ```cpp
  template<typename T>
  void SomeTemplateClass<T>::SomeMemberName(SomeParamList);
  ```

- 对于一个实例化了的类模板，其成员只有在使用时才被实例化。这一特性使得即使某种类型不能完全符合模板操作的要求，我们仍然能用该类型实例化类。
- 在类模板自己的作用域（包括模板外部的函数定义中，类名以后的部分，不包括外部函数定义的返回值）内可以省略模板参数。
- 将所有的类模板实例声明为友元需要指定不同的模板参数。
  
  ```cpp
  template <typename T>
  class T1;

  template <typename T>
  class T2 {
    template <typename X>
    friend class T1;
  };
  ```

- 为模板而非模板类型定义别名：
  
  ```cpp
  template <typename T1, typename T2>
  class T {};

  template <typename X>
  using Alias = T<X, X>;

  Alias<int> x; // T<int, int>
  ```
- 类模板的每个实例都有独有的 `static` 对象。不过同样只有在使用时才初始化。
- 不同于其他的上下文，模板参数名不可被重用。 
- 在模板外为模板的模板成员函数定义：
  
  ```cpp
  template <typename T>
  class K {
    template <typename _T>
    void foo();
  };

  template <typename T>
  template <typename _T>
  void K<T>::foo() {}
  ```
- 若多个独立的源文件使用了相同的模板，将导致多次实例化同一个类，可以手动控制实例化避免额外的开销：
  
  ```cpp
  // 仅声明该实例化类型，表示不在当前文件进行实例化。
  extern template class std::vector<int>;

  // 显式要求实例化该类型。
  template class std::vector<std::string>;
  ```

  但是此时的实例化无法得知其他地方的使用情况。所以必须实例化该类的所有成员。而非像普通实例化一样，仅在使用到成员时实例化成员。也就是此时所有类型必须能用于模板所有成员函数。

# 16.2 模板实参推断

- 调用时的类型转换（在没有显式指定模板参数的情况下）：非 `const` 到 `const` 的转换，数组向非引用形参首元素指针的转换和函数向非引用形参函数指针的转换。其他转换不能应用于函数模板，而是生成新的模板实例。
- 标准库 `type_traits` 提供了类型操作的若干工具，例如 `using T = std::add_const<int>::type;` 获得 `T` 为 `const int`。
- `add_rvalue_reference` 与 `add_lvalue_reference`：这两个工具若接受的参数是引用，其目的在于对接受的参数添加引用。例如 `add_rvalue_reference<T&>` 的理想返回值为 `T` 的左值引用的右值引用，最终结果按照 `reference collapsing` 计算。
- `reference collapsing`：标准允许借助 `typedef` 一类的工具定义一个类型的多重引用，但是会 `collapse`：
  
  ```cpp
  class B {};
  using LeftRef = B&;
  using RightRef = B&&;
  using LeftRightRef = RightRef&;   // 左值引用的右值引用 为 左值引用
  using RightLeftRef = LeftRef&&;   // 右值引用的左值引用 为 左值引用
  using LeftLeftRef = LeftRef&;     // 左值引用的左值引用 为 左值引用
  using RightRightRef = RightRef&&; // 右值引用的右值引用 为 右值引用
  ```

  （个人推断）

  右值不允许取址/赋值，但是右值引用对象可以。

  用 `object` 表示类型为引用的变量，用 `target` 表示这个变量引用的目标。
  - 右值引用的左值引用：可以理解为对于两次引用后的结果进行的任何操作都是在修改右值引用 `object`，而非修改右值引用 `target`。如此一来引用结果就等同于一个普通的左值引用了（即对左值引用后的结果重新赋值是让这个 `object` 引用新的目标，而非直接修改右值表达式）。 
  - 左值引用的右值引用：可以理解为此处的右值引用实际引用的是左值引用 `object`，将其作为一个右值处理，但是不把这个 `object` 指向的 `target` 作为右值处理（即对右值引用后的结果重新赋值是让左值指向新的 `target`）。
  - 总结就是考虑一条引用链，每个引用都是左值或者右值引用。那么对于引用结果的修改可以理解为从后往前找到的第一个左值引用的修改。那么这种情况下只有所有的引用都为右值才能使最终结果无法修改，同为右值。

  此外，当使用一个右值引用时应当区分这个变量是以类型为右值引用的左值出现，还是以引用对象的右值出现。

  例如在调用函数时传入某个右值引用对象（非 `std::move`），那么实际使用的是类型为右值引用的对象左值，此时优先调用重载函数的左值版本。除非显式调用 `std::move`，否则不会调用右值版本。然后若函数接受的是值类型，那么按照引用对象的值进行拷贝初始化。若函数接受的是左值引用类型，则该右值引用对象会被进行一次左值引用，按照引用折叠原理成为一个原引用对象的左值引用，然后初始化形参（可以理解为函数形参中的 `T&`（`T` 非引用类型）既可以表示 `T` 的左值引用，也可以表示 `T` 的右值引用的左值引用，毕竟这两个的折叠后结果是一样的）。

  ```cpp
  inline void test(int& a) { std::cout << "Left" << std::endl; }

  inline void test(int&& a) {
    std::cout << "Right" << std::endl;
    test(a);
  }

  int main() {
    int a = 1;
    test(std::move(a));
    return 0;
  }
  ```

  输出

  ```
  Right
  Left
  ```

- 当将一个左值传递给函数的右值引用参数，并且此右值引用指向模板类型参数（例 `T&&`），那么编译器推断模板类型参数为实参的左值引用类型。这也就说明模板中的 `T&&` 可以接受任意对象，无论左值或右值。
- ```cpp
  template<typename T> void f(T&&);      // 绑定到非 const 右值
  template<typename T> void f(const T&); // 绑定到左值和 const 右值
  ```
- 完美转发：

  考虑一下转发函数：

  ```cpp
  template <typename F, typename T1>
  void p(F f, T1&& t1) {
    f(std::forward<T1>(t1));
  }
  ```

  参数列表中的 `T1&&` 使得函数可以接受左值和右值。但是在传入 `f` 函数时无法正确处理 `T1` 被推断为非引用类型的情况，此时 `t1` 类型为右值引用，正确情况下应该将 `t1` 使用 `std::move` 进行显式声明为右值。但是对于另外一种情况，也就是 `T1` 被推断为左值引用类型时，不能够添加 `std::move`。

  于是标准库添加了 `std::forward`，应当以显式指明模板类型参数的方式调用。当 `T1` 为非引用类型时，`forward` 返回其右值引用版本。当 `T1` 为左值引用类型时，`forward` 也返回其右值引用版本，但是在引用折叠的影响下，会返回其左值引用类型。于是就能正常的传参了。

# 16.3 重载与模板

- 非模板比模板更加特例化。

# 16.4 可变参数模板

- 可变参数：
  
  ```cpp
  template <typename T, typename... Args>
  void foo (const T &t, const Args &...rest);
  ```

  使用 `sizeof...` 获取元素个数：

  ```cpp
  sizeof...(Args)
  sizeof...(args)
  ```

- 非可变参数模板比可变参数模板更特例化。
- 扩展中的元素会独立的应用于包中的每个元素。

# 16.5 模板特例化

- 特例化的本质是实例化而非重载。
- 只能部分特例化类模板，而不能部分特例化函数模板。
- 对于类的特例化，每个未完全确定的类型的模板参数，在特例化版本的模板参数列表都有一项与之对应。部分特例化版本的模板参数列表是原始模板的参数列表的一个子集或者是一个特例化版本。
- 可以只特例化成员函数而不是整个模板，此时其他成员由模板提供。