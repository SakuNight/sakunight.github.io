---
title: 第 3 章 字符串、向量和数组
categories:
- Book
- C++ Primer （第 5 版）
---
# 3.1 命名空间和 `using` 声明

`using namespace::name;`

例如：

`using std::cin;`

# 3.2 标准库类型 `string`

- 当使用 `cin >> string` 时，会忽略空白字符，仅保留有效字符。
- 当使用 `getline(istream, string)` 时，遇到换行符停止，此时换行符会被消耗，但是不会被存入 string。
- `string::size_type` 是 `sized` 函数的返回值，注意这个值是无符号整数。例如若 `n` 是一个具有负值的 `int`，则 `s.size() < n` 结果几乎肯定是 `true`，此时 `n` 会被转换成比较大的无符号值。
- 初始化方式
  
  |        源代码         |         初始化方式          |
  | :-------------------: | :-------------------------: |
  |      `string s1`      |             空              |
  |    `string s2(s1)`    |            副本             |
  |   `string s2 = s1`    |            副本             |
  | `string s3("value")`  |   除最后的空字符外的副本    |
  | `string s3 = "value"` | 等价于 `string s3("value")` |
  |  `string s4(n, 'c')`  |    `'c'` 简单重复 `n` 次    |

  注意按照 `string s3 = "value"` 初始化时，右侧是单个字符串字面量，而非表达式结果。
- 范围 `for`: `for(declaration: expression)`。例如：`for(auto c: str)`，其中 `str` 为 `std::string`，如果需要修改变量，可以将定义改为引用类型`for(auto &c: str)`。

# 3.3 标准库类型 `vector`

- 不存在包含引用的 `vector`。除此之外，其他大多数非引用内置类型和类类型都可以构成 `vector` 对象。
- 初始化方式
  |          源代码           |                     初始化方式                     |
  | :-----------------------: | :------------------------------------------------: |
  |      `vector<T> v1`       |                         空                         |
  |    `vector<T> v2(v1)`     |                        副本                        |
  |    `vector<T> v2 = v1`    |                        副本                        |
  |  `vector<T> v3(n, val)`   |                 `n` 个重复的 `val`                 |
  |     `vector<T> v4(n)`     |          `n` 个重复地执行了值初始化的对象          |
  | `vector<T> v5{a,b,c,...}` | 包含了初始值个数的元素，每个元素被赋予相应的初始值 | + |

  | `vector<T> v5={a,b,c,...}` |           等于 `vector<T> v5{a,b,c,...}`           |

  注意使用初始元素值列表时不能用小括号。

- 当花括号包围的值无法作为列表初始化时，会尝试构造 `vector`，例如 `vector<string> v{1};`。
- 如果循环体内部包含向 `vector` 添加元素的语句，那么不能使用范围 `for` 循环。

# 3.4 迭代器介绍

- 操作
  
  |               操作                |                        含义                         |
  | :-------------------------------: | :-------------------------------------------------: |
  |              `*iter`              |                 获取所指元素的引用                  |
  |            `iter->mem`            | 获取该元素的名为 `mem` 的成员，等价于 `(*iter).mem` |
  |             `++iter`              |               指向容器中的下一个元素                |
  |             `--iter`              |               指向容器中的上一个元素                |
  | `iter1 == iter2 / iter1 != iter2` |             判断指示的是/不是同一个元素             |

- `const_iterator`: 仅允许读元素，不允许写。如果 `vector` 和 `string` 对象是常量，那么必须用 `const_iterator`。
- `begin()` 和 `end()` 返回类型为 `iterator` 或 `const_iterator` 由对象是否是常量决定。`cbegin()` 和 `cend()` 则必定返回 `const_iterator`。
- 任何可能改变 `vector` 的操作都会使迭代器失效。
- 迭代器相减的结果为它们之间的距离。

# 3.5 数组

- 定义数组必须指定数组的类型，不允许使用 `auto` 由初始值列表推断。
- 数组元素为对象，因此不存在引用的数组（但是存在数组的引用）。
- 字符数组可以用字符串字面量初始化。
- 不存在引用的数组，但是存在数组的引用(`int (&arrRef)[10] = arr;`)。
- 数组的指针：`int (*Parray)[10] = &arr;`。指针的数组：`int *ptrs[10];`(由内向外理解)。
- 列表初始化时，若列表元素个数不足，会将剩余元素补为默认值。因此可以使用空列表(`= {}`)初始化，以将所有元素置为默认值（否则可能为未初始化的）。
- 使用 `auto` 推断时，数组返回的是指针（指向首元素），使用 `decltype` 推断时，数组返回的是数组。
- 获取尾后指针可以使用取址符，尽管这个地址不应该被解引用。
- `<iterator>` 中的 `begin` 和 `end` 函数可以用于获取首指针和尾后指针。
- `std::string` 可以使用 `c_str` 成员函数获取 C 风格的字符串（字符数组）。
- `std::string` 的加法中，可以使用**以空字符结束**的字符数组作为其中一个运算对象。
- 数组可以用于初始化 `vector`: `vector<int> ivec(begin(int_arr), end(int_arr));`。参数分别为（要拷贝的）首元素指针与（要拷贝的）尾后元素指针。

# 3.6 多维数组

- 一般约定二维数组的第一个参数指定行，第二个参数指定列。
- 由内向外解释更方便。
- 初始化时可以内嵌花括号（一般括号个数为行数，每个括号内元素个数为列数），也可以不内嵌。不过若内嵌了花括号，那么每个花括号对应一行，此时初始化结果不等于直接去掉花括号的初始化结果。
- 使用 `auto` 引用推断类型来执行范围 `for`:
  
  ```cpp
  int a[2][2] = {1, 1, {1, 2}};
  for (auto &i : a) {
    for (auto &j : i) {
      printf("%d\n", j);
    }
  }
  ```

  也可以利用 `auto` 不带引用会推断为指针的特性遍历：

  ```cpp
  for (auto p = a; p != a + 2; ++p) {
    for (auto q = *p; q != *p + 2; ++q) { // 解引用符获取下一层数组的首指针
      printf("%d\n", *q);
    }
  }
  ```

- 使用 `typedef` 定义数组类型：`typedef int int_array[4];` 定义 `int_array` 为长度为 4 的 `int` 型数组。这是因为 `typedef int` 整体作为基本数据结构出现，而 `[4]` 作为声明符出现。