---
title: 第 19 章 特殊工具与技术
categories:
- Book
- C++ Primer （第 5 版）
---
# 19.1 控制内存分配

- 签名：
  ```cpp
  void *operator new (size_t);
  void *operator new[] (size_t);
  void *operator delete (void *) noexcept;
  void *operator delete[] (void *) noexcept;
  void *operator new (size_t, nothrow_t &) noexcept;
  void *operator new[] (size_t, nothrow_t &) noexcept;
  void *operator delete (void *, nothrow_t &) noexcept;
  void *operator delete[] (void *, nothrow_t &) noexcept;
  ```
- 如果目标是类类型，编译器首先查找类及其基类作用域，其次是全局作用域。
- `new` 与 `delete` 是隐式静态的。
- `delete` 必须为 `noexcept`，`new` 在第二个参数为 `nothrow_t&` 时为 `noexcept`。重载时必须保证 `noexcept` 对应正确。
- 如果不是重载，而是自定义，那么必须使用定位形式（例如 `new (nothrow) int`），此时可以自定义新增的形参，例如：
  
  ```cpp
  void *operator new(size_t, customized_type);
  ```

  但是以下这个形式不能被用户重载：

  ```cpp
  void *operator new(size_t, void*); // 这个情况下 new 仅构造函数，不分配内存
  ```
- 对于 `delete` 和 `delete[]`，如果是类的成员，那么可以包含另外一个 `size_t` 形参（未在上文签名中列出，因为标准不需要），其代表第一个形参所指对象的字节数。
- 重载 `new` 与 `delete` 格式与重载运算符相似，但是实质不同。`new` 总是调用 `operator new` 函数获取内存空间后构造对象；`delete` 总是销毁对象后调用 `operator delete` 函数释放所占空间。

# 19.2 运行时类型识别

- `dynamic_cast<type*>(e) / dynamic_cast<type&>(e) / dynamic_cast<type&&>(e)`：类型必须满足以下三个条件之一：
  - `e` 的类型是 `type` 类型的公有派生类
  - `e` 的类型是 `type` 类型的公有基类
  - `e` 的类型是 `type` 类型
- `typeid` 在接受引用时，返回所引对象的类型。在接受函数或数组时不会执行向指针的类型转换。
- 当 `typeid` 接受类类型对象且类型中有虚函数时才会对表达式求值，否则返回表达式的静态类型。

# 19.3 枚举类型

- 限定作用域枚举类型：`enum (class / struct) enum_name: internal_integer_type { enum_members... };`。不限定作用域的枚举类型：`enum (enum_name)? { enum_members... };`。
- 默认情况下，枚举值从 0 开始。如果没有显式地提供初始值，则当前枚举成员的值等于之前枚举成员的值 + 1。
- 提供的初始值必须是常量表达式。
- 不限定作用域的枚举类型成员能隐式转换成 `int`，限定作用域的不能。
- 不限定作用域的枚举类型不指定成员默认大小。

# 19.4 类成员指针

- 初始化成员指针或为其赋值时，它并未指向任何数据。成员指针指定了成员而非该成员所属的对象。
- 对一个对象或指针使用 `.*` 或 `->*`  访问成员指针指定的成员。
- 在成员函数和指向该成员的指针之间不存在自动转换规则。
- 当使用成员函数指针赋值 `function` 对象时，必须指定该对象所能表示的函数类型。此时 `function` 对象会自动采用正确的方式处理 `this` 绑定以及调用方式。第一个参数指明成员是在哪个对象上执行的，同时还必须指明以指针或引用形式传入的。
- 可以使用 `std::mem_fn` 自动生成可调用对象。此时可以通过对象调用，也可以通过指针调用。
- 还可以使用 `std::bind(target_member_function_ptr, _1, ...)` 隐式绑定第一个参数到 `this`。此时接受的也是指针或引用。

# 19.6 `union`：一种节省空间的类

- `union` 不能继承自其他类，也不能作为基类被继承，因此不能有虚函数。此外还不能有引用类型的成员。
- 匿名 `union` 不能包含受保护的成员或私有成员，也不能定义成员函数。
- 如果 `union` 含有类类型的成员，并且该类型自定义了默认构造函数或拷贝控制成员，则编译器将为 `union` 合成对应的版本并将其声明为删除的。常用 `class` 或 `struct` 包一层 `union` 方便用。

# 19.7 局部类

- 局部类只能访问外层作用域中的类型名，静态变量以及枚举成员。
- 局部类的嵌套类可以定义在局部类外，但是局部类的嵌套类的成员必须定义在该嵌套类内。

# 19.8 固有的不可移植的特性

- 定义： `(unsigned)bit_field_type bit_field_name: bit_field_length;`
- 位域一般使用无符号数。相邻的位域可能压缩在同一整数的相邻位。
- 合成的(拷贝/移动)对 `volatile` 无效。
- 指向 C 函数的指针和指向 C++ 函数的指针是不一样的类型。
- 链接指示同时作用于声明语句中的所有函数。
- 如果希望给 C++ 函数传入指向 C 函数的指针，则必须使用类型别名：
  
  ```cpp
  extern "C" typedef void FC(int);
  void f2(FC *);
  ```
- 通过链接指示对函数定义使得 C++函数可以在其它语言编写的程序中可用。
- C++ 编译器预处理会定义 `__cplusplus` 变量。