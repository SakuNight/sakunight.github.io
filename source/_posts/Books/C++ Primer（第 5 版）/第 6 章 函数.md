---
title: 第 6 章 函数
categories:
- Book
- C++ Primer （第 5 版）
---
# 6.1 函数基础

- 为了与 C 语言兼容，可以使用 `void` 显式地指明函数没有形参。例如：`void f(void) { /* ... */ }`。
- 形参名是可选的，如果某个形参不会被用到，那么可以省略名字。例如：`void func(int) {}`。
- 函数的返回值不能是函数类型或数组类型。
- 局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。将变量定义为 `static` 就可以获得。如果局部静态变量没有显式的初始值，它将执行值初始化（内置类型的局部静态变量初始化为 0）。
- 含有函数声明的头文件应该被包含到定义函数的源文件中。
- 分离式编译时编译包含对象代码的文件：`CC -c source.cc`。其中 `CC` 为编译器，`source.cc` 为源代码。在 Windows 下一般生成 `.obj` 文件，在 Unix 下一般生成 `.o` 文件。

# 6.2 参数传递

- 使用引用传递大的类类型可以避免拷贝，另外某些类类型（例如 IO 类型）不支持拷贝，必须使用引用传递。
- 如果函数无需改变引用形参的值，最好将其声明为常量引用。
- 使用引用形参还可以用于保存函数返回值（常见于像 golang 一样一个函数返回多个值）。
- 函数形参中的数组实际上接收的是指针，且数组长度未知。如果使用数组的引用传递参数，那么长度可知。
- `main` 函数的形参：`int main(int argc, char *argv[]) { /* ... */ }`。其中 `argv[0]` 保存的是程序的名字，可选的实参从 `argv[1]` 开始。
- 可变形参的函数
- - `initializer_list`:
 
    ```cpp
    // Declaration
    void foo(initializer_list<int> il);
    // Call
    foo({ 1, 2, 3 });
    ```
  - 省略符（常见于与 C 函数交互的接口程序）:
    
    **大多数类类型的对象在传递给省略符形参时都无法正确拷贝。**

    ```cpp
    void foo(param_list, ...);
    ```
  - 可变参数模板（尚未介绍）
  
# 6.3 返回类型和 `return` 语句

- `void` 类型的函数 `return` 后面可以跟着表达式，但是必须是其他的返回 `void` 的函数的调用。
- 函数可以返回引用，例如 `std::string &watch(std::string &s)`。同时也可以返回形参（即使形参为引用），这个时候不会发生拷贝。
- 函数完成后，它所占用的存储空间也被随之释放，所以不能够返回指向局部变量的指针或者引用。
- 函数可以返回花括号包围的值的列表。如果列表为空，临时量执行值初始化。如果函数返回的是内置类型，则花括号包围的列表最多包含一个值。
- `cstdlib` 中有两个变量 `EXIT_FAILUE` 和 `EXIT_SUCCESS` 表示主函数的状态对应的返回值。因为是预处理变量，所以不需要 `std::`。
- `main` 函数不能递归调用自己。
- 如果要让函数返回数组的指针：
  
  - 使用类型别名：

  ```cpp
  using arrT = int[10];
  arrt* func(int i);
  ```

  - 不使用类型别名：

  ```cpp
  int (*func(int i))[10];
  ```

  - 使用尾置返回类型（所有类型的返回值都可以用，但是对复杂类型更有效）：

  ```cpp
  auto func(int i) -> int(*)[10];
  ```

  - 使用 `decltype`（略）：注意 `decltype` 得到的结果为数组，因此应该在函数名前添加 `*` 表示指针。

# 6.4 函数重载

- `main` 函数不允许重载。
- 一个拥有顶层 `const` 的形参无法和另一个没有顶层 `const` 的形参区分开来。
- 二义性调用：有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。
- 名字查找发生在类型检查之前，这也就是说函数内部定义的函数无法与外部的函数重载。

# 6.5 特殊用途语言特性

## 默认实参

- 用作默认实参的名字在函数声明所在的作用域内解析（而非调用时的作用域），而这些名字的求职过程发生在函数调用时（而非声明时）。

## 内联函数和 `constexpr` 函数

- `constexpr` 函数要求：
  - 函数的返回类型及所有形参的类型都是字面值类型。
  - 函数体中必须有且只有一条 `return` 语句（不过 C++14 放开了这个限制）。

## 调试帮助

- `assert` 为预处理变量，因此不允许自行定义名为 `assert` 的变量、函数或其他实体。
- 可以通过定义 `NDEBUG` 预处理变量以使 `assert` 失效，也可以使用这个预处理变量编写自己的调试逻辑。
- 预处理器定义的变量：
  - `__func__`：当前调试的函数的名字，时 `const char` 的一个静态数组。
  - `__FILE__`：存放文件名的字符串字面值。
  - `__LINE__`：存放当前行号的整型字面值。
  - `__TIME__`：存放文件编译时间的字符串字面值。
  - `__DATE__`：存放文件编译日期的字符串字面值。

# 6.6 函数匹配

- 实参到形参类型的转换等级：
  - 精确匹配：
    - 实参类型和形参类型相同。
    - 实参从数组类型或函数类型转换成对应的指针类型。
    - 向实参添加顶层 `const` 或者从实参中删除顶层 `const`。
  - 通过 `const`  转换实现的匹配。
  - 通过类型提升实现的匹配。 
  - 通过算数类型转换或指针转换实现的匹配。
  - 通过类类型转换实现的匹配。

# 6.7 函数指针

- 当我们把函数名作为一个值使用时，该函数自动地转换成指针。
  
  ```cpp
  void func();
  f = func;
  f = &func;
  ```

  上面示例中两行赋值代码相同。

- 可以直接使用指向函数的指针调用该函数，无须提前解引用指针。
- 指针类型必须与重载函数中的某一个精确匹配。
- `typedef` 定义函数类型：`typedef void func();`。其中 `func` 为函数名。和之前一样，`typedef void`（或者加上形参列表？） 作为基本数据结构出现。
- 形参是函数类型时，会自动地转换成指向函数的指针。
- `decltype` 推断出的函数类型不为指针，因此需要手动添加`*`。
- 返回函数时必须手动指明指针（或者声明时声明为指针）。