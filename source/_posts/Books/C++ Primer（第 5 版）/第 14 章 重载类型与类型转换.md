---
title: 第 14 章 重载类型与类型转换
categories:
- Book
- C++ Primer （第 5 版）
---
# 14.1 基本概念

- 除了重载的函数调用运算符之外，其他重载运算符不能含有默认实参。
- 如果运算符函数是成员函数，则第一个运算对象绑定到隐式的 `this` 指针上。对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数。
- 运算时按照函数重载匹配规则匹配，以下代码会报错。
  
  ```cpp
    class T {
    };
    class S {
        int operator+(T& y) { return 1; }
    };
    int operator+(S& x, T& y) { return 0; }
    void test() {
        S s;
        T t;
        // clangd:
        // Use of overloaded operator '+' is ambiguous (with operand types 'S' and 'T')
        std::cout << s + t << std::endl;
    }
  ```
- 运算符函数可以直接调用，例如 `data1.operator+=(data2);`，尽管在测试 `std::cout` 传入 `const char*` 的时候输出成了地址（强制类型转换为 `std::string` 会报错）...
- 不建议重载：
  - 逻辑与、逻辑或、逗号运算符求值顺序无法保留。
  - `&&`、`||` 短路求值无法保留。
- `=`，`[]`，`()`，`->` 必须定义为成员函数。复合赋值，改变对象状态的运算符（例如递增、递减）一般为成员。
- 具有对称性的运算符可能转换任意一端的运算对象的类型。通常是非成员函数。

# 14.2 输入和输出运算符

- 一般使用复合赋值来实现算术运算符。

# 14.6 递增和递减运算符

- 递增运算符重载
  
  ```cpp
  T& operator++();   // 前置
  ```

  ```cpp
  T& operator++(int);   // 后置
  ```

  后置版本中 `int` 值为 `0`，一般不会用上（不用命名）。

- 为了与内置版本保持一致，一般前置(递增/递减)返回引用，后置版本返回值。

# 14.7 成员访问运算符

- 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。

# 14.8 函数调用运算符

- 标准库函数对象：
  
  |        算术        |         关系          |        逻辑         |
  | :----------------: | :-------------------: | :-----------------: |
  |    `plus<Type>`    |   `equal_to<Type>`    | `logical_and<Type>` |
  |   `minus<Type>`    | `not_equal_to<Type>`  | `logical_or<Type>`  |
  | `multiplies<Type>` |    `greater<Type>`    | `logical_not<Type>` |
  |  `divides<Type>`   | `greater_equal<Type>` |
  |  `modulus<Type>`   |     `less<Type>`      |
  |   `negate<Type>`   |  `less_equal<Type>`   |

  例：

  ```cpp
  extern std::vector<std::string> svec;
  std::sort(svec.begin(), svec.end(), std::greater<std::string>());
  ```

  使用标准库的函数对象比较指针是良好定义的（实际是比较指针地址）。而直接使用运算符比较则是未定义的。

- `lambda` 类型不能够直接转换为函数类型，因为 `lambda` 表达式是未命名类型的一个未命名对象。标准库提供了 `std::function` 模板，这个模板可以接受可调用类型。
  
  例：

  ```cpp
  function<int(int)> f;
  function<int(int)> f(nullptr);
  function<int(int)> f(some_func);
  function<int(int)>::argument_type; // 一个类型，仅在参数列表长度为 1 时可用
  function<int(int, int)>::first_argument; // 仅在参数列表长度为 2 时可用，还有 second_argument
  function<int(int)>::result_type;
  ```

  对于重载的函数，需要显式指明函数指针。

  例：

  ```cpp
  const int func(const int& x, const int& y) { return 0; }
  int func(int& x, int& y) { return 0; }
  const int (*func_ptr)(const int&, const int&) = func;
  std::function<const int(const int&, const int&)> foo(func_ptr);
  ```

  或者用 `lambda` 包一层。

- 类型转换运算符必须为成员函数且一般为 `const`（即不修改类的内容）。

# 14.9 重载、类型转换与运算符

- 隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后。
- 添加 `explicit` 可以指定为显式的转换，但是以下情况依然隐式执行：
  - `if`，`while`，`do` 的条件部分。
  - `for` 语句条件表达式。
  - `!`，`||`，`&&`，`&&` 运算对象。
  - `? :` 条件表达式。 
- 最好不要定义两个(转换源/转换对象)都是算术类型的类型转换。
- 如果两个类型转换函数之前货之后存在标准类型转换，则标准类型转换将决定最佳匹配是哪个。
- 调用重载函数时，即使其中一个需要额外的标准类型转换而另一个不用，也是有二义性的的。
- 当使用运算符 `a sym b` 时，候选函数集包括：
  - `a.operatorsym(b)`：成员函数。
  - `operatorsym(a, b)`：普通函数。