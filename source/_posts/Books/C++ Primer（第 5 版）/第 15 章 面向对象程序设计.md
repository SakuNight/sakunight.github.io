---
title: 第 15 章 面向对象程序设计
categories:
- Book
- C++ Primer （第 5 版）
---
# 15.2 定义基类和派生类

- 基类通常都应该定义一个虚析构函数。
- 虚函数：基类希望派生类覆盖。
- 派生类构造函数首先初始化基类的部分，然后按照声明顺序依次初始化派生类的成员。
- 派生类仅声明不定义时不指定派生列表。
- 在(类/成员函数)名后面添加 `final` 可以指明(类/成员函数)不应被继承，`final` 出现在参数列表后面。

# 15.3 虚函数

- 动态绑定仅在通过指针或引用调用虚函数时才会发生。
- 当类的虚函数返回类型是类本身的指针或引用时，虚函数调用形式（call signature）可以与基类不用（仅返回值，例如基类 `B` 返回 `B*`，则派生类 `D` 可以返回 `D*`）。
- 手动在参数列表后指定 `override` 可以让编译器在未覆盖虚函数（例如不小心写错了调用形式）时报错。
- 虚函数默认实参按照**静态类型**决定，而非动态类型。
- 强制回避动态绑定：
  
  ```cpp
  class B {
   protected:
    virtual void foo() const {}
  };

  class D : B {
    void foo() const override { this->B::foo(); }
  };
  ```

# 15.4 抽象基类

- 纯虚函数定义：`= 0`；含有纯虚函数的类是抽象基类，不能创建抽象基类的对象。
- 派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员，对于普通的基类对象中的成员不具有特殊的访问权限。
  
  ```cpp
  class B {
    protected:
      int m;
  };

  class D {
    friend void foo(const B&, const D&);

    protected:
      int m;
  };

  void foo(const B& b, const D& d) {
    auto t2 = d.m;  // ok
    auto t = b.m;   // 'm' is a protected member of 'B'
  }
  ```

# 15.5 访问控制与继承

- 派生访问说明符控制派生类用户（包括派生类的派生类）对于基类成员的访问权限。
- 对于代码中的某个给定节点来说，如果派生对象中的基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的，反之则不行。
- 基类的友元可以访问派生类中属于基类的成员。
- 使用 `using` 修改派生类继承的某个名字的访问级别。

# 15.6 继承中的类作用域

- 派生类中的函数不会重载声明在外层作用域的函数，而是覆盖。

# 15.7 构造函数与拷贝控制

- 虚析构函数确保 `delete` 时动态绑定正确的析构函数。一个基类总是需要析构函数。
- 若基类的析构函数不是虚函数，`delete` 一个指向派生类对象的基类指针是未定义的。
- 关于派生类中的删除的拷贝控制与基类的关系（总结的，书上的写的有点乱）：
  - 基类的析构函数如果是删除的或者不可访问的，派生类的构造函数（无论是默认构造函数、拷贝构造函数还是移动构造函数）都是删除的，不能重载（无法重载 `delete` 的成员函数）。
  - 基类的默认构造函数、拷贝构造函数、拷贝赋值运算符、移动构造函数或移动赋值运算符若是删除的或是不可访问的，则派生类中的对应函数的默认值是删除的。但是可以自行重载（对于构造函数，可以显式调用其他可以访问并调用的构造函数初始化基类部分成员）。
- 继承构造函数：`using BaseType::BaseType`。类似于普通成员的 `using`，但是构造函数的访问级别不会受到 `using` 声明位置影响。且不会继承默认、拷贝和移动构造函数。派生类中的构造函数可以覆盖继承的构造函数。