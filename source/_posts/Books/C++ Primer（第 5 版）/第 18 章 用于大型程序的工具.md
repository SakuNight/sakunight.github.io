---
title: 第 18 章 用于大型程序的工具
categories:
- Book
- C++ Primer （第 5 版）
---
# 18.1 异常处理

- 栈展开过程中如果退出了某个块，这个块中的对象将被销毁。一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。
- 所有标准库类型都能确保它们的析构函数不会引发异常。
- 异常对象的类型取决于表达式的静态编译时类型。
- `catch` 不能声明右值引用（但是可以使左值引用）。如果 `catch` 的参数是基类类型，则可以使用其派生类类型的异常对象对其进行初始化，此时如果是非引用，那么切掉一部分，如果是引用，则以常规方式绑定。
  
  注意以下情况：

  ```cpp
  class B {
    public:
      int b;
  };

  class D : public B {
    public:
      int b;
  };

  int main () {
      D d;
      d.b = 1;
      B b = d;
      std::cout << b.b << std::endl;
      std::cout << d.b << std::endl;
      B &bref = d;
      std::cout << bref.b << std::endl;
      return 0;
  }
  // 输出：
  -8784
  1
  -8784
  ```

  即使 `signature` 相同，成员还是会无条件覆盖。只有 `virtual member function` + 引用 才会调用基类的成员。

- `catch` 按照出现顺序匹配而非最佳匹配。仅允许以下三个转换：
  - 非 `const` 到 `const`
  - 派生类向基类
  - 数组与函数的指针
  
  即使内置类型间也不允许转换。
- 重新抛出：`throw;`。仅允许在 `catch` 及其调用函数中出现。
- 捕获所有异常：`catch(...)`
- 处理(构造函数 / 析构函数)初始化过程异常：在参数列表与冒号间写 `try`，在函数体后 `catch`。但是此时同其他函数一样，无法捕捉初始化参数时的异常。
- `noexcept`：跟在参数后面时作为说明符出现，在 `noexcept` 实参中时，作为一元运算符出现，表示接受的函数调用是否会抛出异常（手动指定的 `noexcept` 而非编译器检查）。
- 函数指针及该指针所指的函数必须具有一致的异常说明。

# 18.2 命名空间

- 模板特例化必须定义在原始模板所属的命名空间中。
- 内联命名空间：在第一次定义时必须加 `inline`，后续可以不加。外部作用域可以直接访问内联命名空间的成员。常用于更新版本，将最新版的命名空间作为内联，旧版则需要显式指定访问。
- 无名命名空间：取代 C 语言静态变量。无名命名空间在多个文件中是不同的实体。其生命周期等同于其所处作用域的生命周期。
- `using` 指示一般被看作出现在最近的外层作用域中。 
- 当给函数传递类类型对象时，除了常规的作用域查找外，还会查找实参类**所属（而非类的内部）**的命名空间（例如重载运算符）。此时类作用域内的声明，包括**友元函数**，都会被纳入查找范围。
- `using` 声明会重载声明语句所属作用域其他同名函数（同名且形参相同的话会报错），隐藏外层作用域相关声明。`using` 指示会重载。

# 18.3 多重继承与虚继承

- 从多个基类中分别继承名字相同的成员是完全合法的，只不过使用时必须明确指出它的版本，否则具有二义性。
- 虚基类：不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。
- 派生类成员优先级高于共享虚基类成员优先级。
- 虚基类由最低层派生类初始化，即使虚基类不是其直接基类。