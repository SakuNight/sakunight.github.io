---
title: 第 11 章 关联容器
categories:
- Book
- C++ Primer （第 5 版）
---
# 11.2 关联容器概述

- 使用初始值列表初始化 `map`：外层花括号包含内层花括号，内层花括号中包含两个值，一个键值，一个对应值。
- 指定比较函数时需要在容器类型尖括号中添加函数类型的指针，可以使用 `decltype(compare_func)*`。注意需要显式添加 `*`。

# 11.3 关联容器操作

- `map` 的 `pair` 中的键值部分是 `const` 的。
- `set` 定义了 `iterator`，但是同 `const_iterator` 一样是只读的。
- 迭代器遍历 `map`，`multimap`，`set`，`multiset` 时，按照关键字升序遍历。
- 对于关联容器，使用容器成员函数 `find` 优于 `std::find`。
- `insert` 和 `emplace` 时可以把第一个参数传为迭代器，可以指定从哪里开始搜索新元素存储的位置。此时返回一个迭代器，指向具有给定关键字的元素。默认情况（非 `multimap`）下返回 `pair`，成员为指向指定关键字的元素的迭代器以及插入是否成功的 `bool`。注意 `map` 的元素为 `pair`。
- `map` 使用下标访问时会默认插入不存在的键值，而使用 `at` 访问时会在不存在时抛出 `out_of_range` 异常。
- 如果一个 `multimap` 或 `multiset` 中有多个元素具有指定关键字，则这些元素在容器中会相邻存储。`find` 会找到第一次出现，因此可以从 `find` 返回的迭代器递增遍历。或者可以使用 `lower_bound` 和 `upper_bound`。或者使用 `equal_range`，该函数返回 `pair`。

# 11.4 无序容器

- 针对桶（存放哈希值相同的对象的地方）的操作：
  - 接口
    - `bucket_count()`：桶的数目。
    - `max_bucket_count()`：能容纳的最多的桶的数量。
    - `bucket_size(n)`：第 `n` 个桶中的元素数量。
    - `bucket(k)`：关键字 `k` 所在的桶。
  - 迭代
    - `local_iterator`
    - `const_local_iterator`
    - `begin(n), end(n), cbegin(n), cend(n)`：桶 `n` 的(首/尾后)元素(常量/非常量)迭代器
  - 哈希策略
    - `load_factor()`：每个桶的平均元素数量(float)。
    - `max_load_factor()`：试图维护的平均桶大小(float)。需要时会添加新的桶。
    - `rehash(n)`：重组存储，使得 `bucket_count >= n` 且 `bucket_count > size / max_load_factor`
    - `reserve(n)`：重组存储，使得可以保存 `n` 个元素且不必 `rehash`。
- 标准库为内置类型和一些标准库类型定义了 `hash`。
- 无需容器可以接受自定义哈希函数与相等判断函数(返回 `bool`)，同关联容器比较函数一样可以使用 `decltype(eq_func)*` 类型，其中 `eq_func` 为自定义的比较函数。