---
title: 第 10 章 泛型算法
categories:
- Book
- C++ Primer （第 5 版）
---
# 10.2 初始泛型算法

- `back_inserter`（插入迭代器） 可以用于便捷调用 `push_back`。
  
  ```cpp
  std::vector<int> V;
  auto it = std::back_inserter(V);
  std::fill_n(it, 10, 0);
  std::cout << V.size() << std::endl;
  ```

  这种迭代器的自增会返回自身，赋值会调用 `push_back`。

# 10.3 定制操作

- `lambda` 函数不能有默认参数。
- 被 `lambda` 捕获的值是创建时拷贝而非调用时。
- 若函数返回 `lambda`，此 `lambda` 不能包含引用捕获。
- `[=]`：隐式值捕获。`[&]`：隐式引用捕获。隐式捕获可以和显式捕获一起指定，此时隐式捕获必须为第一个指定，而且显示捕获必须采用不同的方式。
- `mutable` 使值捕获可以改变。但是和捕获对象没有关系，修改后的值也不会在多次调用间共享。
- 如果一个 `lambda` 体包含 `return` 之外的任何语句，编译器都会假定此 `lambda` 返回 `void`。
- `std::bind` 接受一个可调用对象和一个参数列表，返回一个可调用对象，它会将参数列表传入接受的函数，可以使用 `std::placeholders` 中的 `_1`, `_2`......来表示新可调用对象接受的参数。传入引用时，应当使用 `std::ref` 函数生成引用，使用 `std::cref` 生成常量引用。

# 10.4 再探迭代器

- 插入迭代器：`back_inserter`，`front_inserter`，`inserter`
- `istream_iterator`：
  
  ```cpp
  std::istream_iterator<int> in_iter(std::cin), eof;
  std::vector<int> V(in_iter, eof);
  ```

  上例从 `cin` 读取 `int` 初始化 `vector<int>`。当一个 `istream_iterator` 无效时，其值等同于默认初始化的 `istream_iterator`。

  `istream_iterator` 执行自增时从流读入值，解引用时获取最后读入的值的拷贝。

  如果一个 `istream_iterator` 没有使用就销毁，可能尚未读取数据（懒惰求值）。

- `ostream_iterator`：赋值时输出。构造时可以指定第二个参数为每次输出后添加。
- 调用反向迭代器的 `base` 函数可以获得普通版本的迭代器（注意会向后移动一位，因为反向迭代时存在首前迭代器，正向迭代时存在尾后迭代器）。

# 10.5 泛型算法结构

- 迭代器类型
  
  |      名称      |                  特点                  |
  | :------------: | :------------------------------------: |
  |   输入迭代器   |     只读不写；单遍扫描，只能递增。     |
  |   输出迭代器   |     只写不读；单遍扫描，只能递增。     |
  |   前向迭代器   |      可读写；多遍扫描，只能递增。      |
  |   双向迭代器   |     可读写；多遍扫描，可递增递减。     |
  | 随机访问迭代器 | 可读写；多遍扫描，支持全部迭代器运算。 |

# 10.6 特定容器算法

- `list` 和 `forward_list` 特有成员函数：
  - `merge`：接受必选的同类型对象，将其元素合并，然后删除在接收对象中的元素。当前对象和接受对象都必须有序。可选传入一个比较函数。
  - `remove(_if)`
  - `reverse`
  - `sort`：可选比较函数（性能比通用版本（`std::sort`）更高）。
  - `unique`；可选二元谓词。
  - `splice(_after)`：必须传入一个当前对象的迭代器，以及一个新的同类型对象。可选传入一个或两个传入对象的迭代器指定范围。该函数将指定的迭代器范围元素加到当前对象，不带 `_after` 加入到当前对象迭代器前，带 `_after` 加入到当前对象迭代器后。