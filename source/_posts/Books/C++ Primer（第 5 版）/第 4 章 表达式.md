---
title: 第 4 章 表达式
categories:
- Book
- C++ Primer （第 5 版）
---
# 4.1 基础

- 左值与右值（当为表达式对象时）：
- - 左值：主要用的是对象的身份
- - 右值：主要用的是对象的值

# 4.2 算术运算符

- (m, n 为正整数) `m % (-n)` = `m % n`

# 4.4 赋值运算符

- 赋值运算符满足右结合律。
- 复合运算符，例如 `+=`, `-=`，只会对左边的值进行一次求值。使用普通的运算符则会求值两次。

# 4.5 递增和递减运算符

- 后置版本会存储修改前的值以返回。对于整数和指针类型，编译器可能会进行优化。但是对于迭代器，这是性能浪费。

# 4.7 条件运算符(三元)

- 当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值，否则运算的结果就是右值。
- 右结合律。

# 4.8 位运算符

- 关于符号位如何处理没有明确规定，因此建议仅对无符号行使用位运算符。

# 4.9 `sizeof` 运算符

- 返回一条表达式或一个类型名字所占的**字节**数。其并不实际计算运算对象的值。
- 返回常量表达式（`constexpr`）。
- 右结合律
- 若传入指针，指针不需有效。
- 不会将数组转换为指针处理。
- 对 `string` 或 `vector` 对象执行，只返回固定部分的大小，不会计算对象中的元素占用了多少空间（毕竟是 `constexpr`）。

# 4.10 逗号运算符

- 首先对左侧的表达式求值，然后丢掉。返回的结果是右侧的表达式的值。

# 4.11 类型运算符

- 常量整数值 0 或者字面值 `nullptr` 可以转换成任意指针类型。
- 指向任意非常量的指针能转换成 `void*`。
- 指向任意对象的指针能转换成 `const void*`。
- 强制类型转换（`cast-name<type>(expression);`）：
- `dynamic_cast`：运行时类型识别。
- `static_cast`：只要不包含底层 `const`，就可以使用。
- `const_cast`：只能改变对象的底层 `const`（如果对象是一个常量，那么执行写操作是未定义行为）。
- `reinterpret_cast`：改变类型，例如
  
  ```cpp
  int *ip;
  char *pc = reinterpret_cast<char*>(ip);
  ```
- 旧式：`type (expression);` 或者 `(type) expression`
  
  如果换成 `static_cast` 或者 `const_cast` 也合法，那么其行为与对应的命名转换一致。否则执行与 `reinterpret_cast` 类似的功能。

# 4.12 运算符优先级表