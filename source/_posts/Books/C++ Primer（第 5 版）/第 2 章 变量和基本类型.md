---
title: 第 2 章 变量和基本类型
categories:
- Book
- C++ Primer （第 5 版）
---
- 算术类型数据所占的比特数在不同的机器上有所差别。C++ 标准仅规定最小值。
    |     类型      | 最小尺寸(位) |                                含义                                |
    | :-----------: | :----------: | :----------------------------------------------------------------: |
    |    `bool`     |    未定义    |
    |    `char`     |      8       | 确保存放机器基本字符集中任意字符对应的数字值（和一个机器字节一样） |
    |   `wchar_t`   |      16      |             确保存放机器最大扩展字符集中的任意一个字符             |
    |  `char16_t`   |      16      |                              Unicode                               |
    |  `char32_t`   |      32      |                              Unicode                               |
    |    `short`    |      16      |
    |     `int`     |      16      |
    |    `long`     |      32      |
    |  `long long`  |      64      |
    |    `float`    | 6位有效数字  |
    |   `double`    | 10位有效数字 |
    | `long double` | 10位有效数字 |
- 可寻址的最小内存块称为**字节**。
- 存储的基本单元称为**字**。通常，`float` 以 1 个字（32 比特）来表示，`double` 以 2 个字（64 比特）来表示，`long double` 以 3 或 4 个字（96 或 128 比特）来表示。
- `char` 会表现为 `signed char` 和 `unsigned char` 中的一种，具体是哪种由编译器决定。
- 双精度浮点数和单精度浮点数的计算代价相差无几。对于某些机器来说，双精度甚至比单精度还快。
- 赋给带符号类型一个超出它表示范围的值时，结果是**未定义**的。
- 当一个算术表达式中既有无符号数又有 `int` 值时，那个 `int` 值就会转换成无符号数（把负数转换成无符号数类似于直接给无符号数赋一个负值，结果等于这个负数加上无符号数的模）。
- 关于整型字面值：
- - 以 0 开头的整数代表八进制数，以 0x 或 0X 开头的代表十六进制数。
- - 十进制字面值是带符号数，八进制和十六进制字面值不确定。
- - 十进制字面值的类型是能容纳其数值的 `int`, `long` 和 `long long` 中尺寸最小的那个。
- - 八进制和十六进制字面值的类型是能容纳其数值的 `int`, `unsigned int`, `long`, `unsigned long`, `long long`, `unsigned long long` 中的尺寸最小者。
- - 如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误（指程序运行方式非理想运行方式，而非编译错误）。
- - 严格来说，十进制字面值不会为负，因为负号在字面值之外。
- 泛化的转义序列：`\x` 后面紧跟 1 个或多个十六进制数字，或者 `\` 后紧跟 1 个、2 个或 3 个八进制数字。数字部分表示的是字符对应的数值。
- 添加前缀指定字符串字面值类型：
  
  | 前缀  |      含义       |   类型   |
  | :---: | :-------------: | :------: |
  |   u   | Unicode 16 字符 | char16_t |
  |   U   | Unicode 32 字符 | char32_t |
  |   L   |     宽字符      | wchar_t  |
  |  u8   |      UTF-8      |   char   |

  添加后缀指定整型字面值类型（u/U 可与 l/ll/L/LL 混用）：

  | 后缀  | 最小匹配类型 |
  | :---: | :----------: |
  |  u/U  |   unsigned   |
  |  l/L  |     long     |
  | ll/LL |  long long   |

  添加后缀指定浮点型字面值：

  | 后缀  |    类型     |
  | :---: | :---------: |
  |  f/F  |    float    |
  |  l/L  | long double |

- `nullptr` 是指针字面值。
- 初始化变量与给变量赋值是不同的操作，尽管有时这种区别无关紧要。
- 用花括号初始化变量被称为**列表初始化**，这种初始化在初始值存在丢失信息的风险时会报错（例如用 `double` 初始化 `int`）
- 定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式地初始化，则其值由类确定。
- `extern` 声明一个变量而非定义它，如果赋了初始值，语句就变成了定义了。变量只能被定义一次，但是可以被多次声明。
- 用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。（但是在测试的时候 gcc(12.2.0 -std=c++11) 编译过了）
- 作用域操作符（`::`）左侧为空时，向全局作用域发出请求获取操作符右侧名字对应的变量。
- （左值）引用：将声明符写成 `&d` 的形式来定义引用类型，其中 `d` 是声明的变量名。(不能引用字面量)
- 因为引用本身不是一个对象，所以不能定义引用的引用。（尽管 g++ 测试的时候又编译过了）
- 指针：将声明符写成 `*d` 的形式来定义指针类型，其中 `d` 是声明的变量名。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针（g++ 还是编译过了就是）。
- `void*` 指针可以存放任意对象的地址。
- 从右往左阅读变量的定义时，离变量名最近的符号对变量的类型有最直接的影响（例如 `int *&r` 中 `r` 首先是引用，其次是对指针的引用，最后是对 `int` 型指针的引用）。
- `const` 类型默认仅在文件内有效。如果要在多个文件之间共享 `const` 对象，必须在变量的定义之前添加 `extern` 关键字。
- 初始化常量引用时可以用任意表达式作为初始值。指向常量的指针可以指向非常量。
- 把 `*` 放在 `const` 之前以说明指针本身为常量指针。例如：`const int *const x = &y;`。同样可以从右往左读以理解变量类型。(`*const` 算声明符而非基本类型)
- 顶层 `const`：指针本身为常量。底层 `const`：指针所指的对象是一个常量。
- `constexpr`: 声明为 `constexpr` 的变量一定是一个常量，而且必须用常量表达式初始化（编译时就可以计算结果）。当 `constexpr` 用于声明指针时，会将指针置为顶层 `const`。
- `typedef` 作为声明语句中的基本数据类型的一部分出现。同样能由基本数据类型构造出复合类型。
- `using` 可以用于定义类型别名：`using alias = T;`
- 当使用类型别名声明时，该别名作为基本数据类型出现，因此不能够直接替换别名为原来的样子。
- `auto` 可以在一条语句中声明多个变量，但是所有变量的初始基本数据类型都必须一样（注意顶层 `const` 属于基本数据类型）（而声明符不一定一样）。
- `auto` 一般会忽略顶层 `const`，保留底层 `const`。使用 `const auto` 以明确指出顶层 `const`。但是设置一个类型为 `auto` 的引用时，初始值中的顶层常量属性仍然保留（没有使用 `const auto` 的情况下，依然只能引用对象，无法引用表达式）。
- `decltype`: 
- - 接受表达式为函数：不执行该函数，仅仅推断类型
- - 接受表达式为变量：返回变量类型（包含顶层 `const`，而且变量为引用时会返回引用类型而非引用对象类型）
- - 接受表达式为表达式（？）：返回表达式结果的类型。
- - **注意当表达式的内容是解引用操作时，解引用指针得到的是指针所指对象的引用的类型，而非所指对象的类型，这样 `decltype` 结果类型就和源类型一样，可以给指针所指对象赋值。**
- - **注意若 `decltype` 接受由一对括号包围的变量名时，返回结果必定为引用（此时是按照表达式解析的），可以考虑这种赋值方式：`(variable) = value;`。也就是由括号包围的变量名实际上也是可以赋值的。**
- 赋值语句是会产生引用的表达式，其返回值为左边变量的引用。