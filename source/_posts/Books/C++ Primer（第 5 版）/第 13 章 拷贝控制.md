---
title: 第 13 章 拷贝控制
categories:
- Book
- C++ Primer （第 5 版）
---
# 13.1 拷贝、赋值与销毁

- 拷贝构造函数：
  - 要求：构造函数的第一个参数是自身类型的引用（无所谓 `const` 与否，但是一般为 `const`）。且任何额外参数都有默认值。
  - 发生的时候:
    - 使用 `=` 定义变量。
    - 作为实参传递给非引用类型的形参。
    - 返回类型为非引用类型的函数。
    - 花括号列表初始化数组或聚合类。
- 重载运算符：名为 `operator` 加上运算符的函数。
- 析构函数：
  - 由波浪号加类名组成，没有返回值，没有参数，不能重载。
  - 不同于构造函数，析构函数先执行函数体，再按初始化顺序逆序销毁元素。
  - 对于临时变量，创建它的表达式结束时会销毁。
  - 引用和指针销毁时不会销毁指向的对象。
- 如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。
- 可以在有合成版本的函数后添加 `=delete` 表示这个函数不应该被调用（例如将拷贝赋值函数定义为 `delete` 以禁止赋值）。
- 成员有 `const` 或引用时无法生成合成构造函数。
 
# 13.2 拷贝控制和资源管理

- 类常见的三种状态：
  - 类值行为：拷贝一个值时，副本和原对象完全独立。
    - 拷贝时注意先复制参数，再释放自身，以保证自赋值时的正确性。
  - 类指针行为：副本和原对象使用相同的底层数据。
  - 其他情况：不允许拷贝或者赋值的 IO 类型和 `unique_ptr`，或者有特殊含义的 `inserter_iterator`。

# 13.3 交换操作

- 定义 `swap` 重载函数可以在某些时候优化性能，例如使用 `sort` 一类的算法时（但是全局命名空间是怎么影响到 `std` 命名空间的呢？？？难道 `stl` 里面手动加了 `::` 前缀？？？）。甚至可以在拷贝赋值运算符重载中值引用参数，然后将当前对象和参数 `swap`，由于实参是按照拷贝构造函数构造的，所以不会无限递归。 

# 13.6 对象移动

- 右值引用：和非 `const` 的左值引用相反，仅允许绑定右值，甚至无法绑定一个普通的变量。
- 移动构造函数：和拷贝构造函数区别在于源对象是右值引用，因此必须在完成移动后使源对象处于“销毁它是无害的”的状态（也就是析构函数首先可以执行，其次无害），此时源对象不再指向被移动的资源。不过不应对其值进行任何假设。
- 由于默认情况下，为了保证中途出错时操作可以回滚，内存会被复制。所以为了移动对象，需要显式将函数标记为 `noexcept`，这个关键字加在参数列表和冒号之间。如果不加，可能会执行拷贝而非移动（不过内部有 `throw` 的可能性的话还是不能加，即使可能拷贝）。
- 只有当一个类没有定义任何自己版本的拷贝控制成员（拷贝构造函数 / 拷贝赋值运算符 / 析构函数），且类的每个非 `static` 数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。
- 若指定了 `=default`，以下情况下，移动构造函数依然是删除的：
  - 无法获取某个类成员的移动构造函数（无论是定义了拷贝控制成员却没有定义移动构造函数，还是被定义为删除的或不可访问的）。
  - 类的析构函数为删除的或不可访问的。
  - 有非 `static` 成员是 `const` 或引用。
- 如果一个类定义了移动构造函数或移动赋值运算符，那么合成版本的拷贝构造函数和拷贝复制运算符是删除的（可以显式定义）。
- `move_iterator`：移动迭代器，解引用生成右值引用而非左值。
  - 使用 `make_move_iterator` 生成。
  - 语义上，可以传入一些算法函数，逻辑上由使用者自行保证。
  - 标准库不保证哪些算法适用移动迭代器。
- 在参数列表后面添加 `&` 可以限制对象必须为左值，添加 `&&` 限制对象为右值，如果和 `const` 一起出现，应当出现在 `const` 后面，此时表示对象为两种情况之一。
- 如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。