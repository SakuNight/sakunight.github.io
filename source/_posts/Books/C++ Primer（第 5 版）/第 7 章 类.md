---
title: 第 7 章 类
categories:
- Book
- C++ Primer （第 5 版）
---
# 7.1 定义抽象数据类型

- `this` 是一个常量指针，不允许改变 `this` 中保存的地址。
- 默认情况下，`this` 指向的是非常量版本的类类型，如果要使 `this` 指向常量版本的，应在参数列表后面添加 `const`。这种成员函数被称为**常量成员函数**。
- 编译器首先编译成员的声明，然后才是成员函数体。所以函数体可以使用后面声明的成员。
- 定义在类内部的成员函数默认内联，定义在类外部的成员函数默认不内联。
- 可以使用 `=default` 定义默认构造函数。
- 构造函数初始值列表：位于参数列表与函数体之间，成员名加上括号，括号内包含成员初始值，逗号隔开。
- 在类的外部定义构造函数时不指明返回类型。

# 7.2 访问控制和封装

- `class` 默认成员时 `private` 的，而 `struct` 默认成员是 `public` 的。
- 使用 `friend` 声明友元时一般在类定义的开始或结束前的位置集中声明。
- 最好提供独立的友元函数声明（在类外）。

# 7.3 类的其他特性

- 类可以自定义某种类型在类中的别名。这个定义必须先定义后使用。
- `mutable` 可以声明可变数据成员，这种成员即使在 `const` 对象中也可以被改变。
- 从 C 语言继承而来的类对象声明方式：`class T t;`。等于 `T t;`。
- 友元类：
  
  ```cpp
  class T {
    friend class F;
  };
  ```

   上例中 `F` 为 `T` 的友元类。

- 每个友元函数声明仅对一个函数生效，如果函数被重载，需要对每一个重载后的函数声明友元才能对所有的重载函数生效。
- 友元函数仅仅是影响访问权限，并非普通意义上的声明。因此就算在类的内部访问时，也应当假设他在类的外部可见（部分编译器未严格执行）。

# 7.4 类的作用域

- 如果类中成员使用了外层作用域中的名字，该名字代表类型，那么类不能重新定义改名字。

# 7.5 构造函数再探

- 构造函数初始值列表的初始化顺序是按照成员被定义的顺序，而非在列表中出现的顺序。
- 委托构造函数：
  
  ```cpp
  class T {
    public:
      int m;
      T(int mm): m(mm) {}
      T(): T(0) {} // 使用另外的构造函数来构造
  };
  ```

- 转换构造函数：接受一个实参，从实参转换到类类型的对象。
- 为构造函数指定 `explicit` 可以阻止隐式类型转换，强制要求显式初始化。这个关键字仅在构造函数只有一个实参（转换构造函数）的时候可用。
- 聚合类的条件：
  - 所有成员都是 `public`。
  - 没有定义构造函数。
  - 没有类内初始值。
  - 没有基类，没有 `virtual` 函数。
- 可以使用花括号括起来的成员初始值列表初始化聚合类。
- 字面值常量类条件：
  - 数据成员都是字面值类型
  - 类必须至少有一个 `constexpr` 构造函数（满足其他条天下，默认的也算）。
  - 如果一个数据成员含有类内初始值，则必须是一条常量表达式；或者成员属于某种类类型，则初始值必须用成员自己的 `constexpr` 构造函数。
  - 使用默认的析构函数。

# 7.6 类的静态成员

- 静态成员不能声明成 `const`。
- `static` 只出现在类内部。
- 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。否则编译器可能替换该 `constexpr` 成员，然后找不到定义。(?)